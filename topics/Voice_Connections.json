{
  "content": [
    "|Voice"
  ],
  "Voice": {
    "content": [
      "Voice connections operate in a similar fashion to the Gateway connection. However, they use a different set of payloads and a separate UDP-based connection for voice data transmission. Because UDP is used for both receiving and transmitting voice data, your client must be able to receive UDP packets, even through a firewall or NAT (see UDP Hole Punching for more information). The Discord Voice servers implement functionality (see IP Discovery) for discovering the local machines remote UDP IP/Port, which can assist in some network configurations.",
      "|Voice Gateway Versioning"
    ],
    "Voice Gateway Versioning": {
      "content": [
        "To ensure that you have the most up-to-date information, please use version 4. Otherwise, we cannot guarantee that the Opcodes documented here will reflect what you receive over the socket.",
        "|Gateway Versions",
        "|Connecting to Voice",
        "|Establishing a Voice Websocket Connection",
        "|Heartbeating",
        "|Establishing a Voice UDP Connection",
        "|Encrypting and Sending Voice",
        "|Speaking",
        "|Resuming Voice Connection"
      ],
      "Gateway Versions": {
        "content": [
          [
            [
              "Version",
              "Status",
              "WebSocket URL Append"
            ],
            [
              "4",
              "recommended",
              "?v=4"
            ],
            [
              "3",
              "available",
              "?v=3"
            ],
            [
              "2",
              "available",
              "?v=2"
            ],
            [
              "1",
              "default",
              "?v=1 or omit"
            ]
          ]
        ]
      },
      "Connecting to Voice": {
        "content": [
          "|Retrieving Voice Server Information"
        ],
        "Retrieving Voice Server Information": {
          "content": [
            "The first step in connecting to a voice server (and in turn, a guild's voice channel) is formulating a request that can be sent to the Gateway, which will return information about the voice server we will connect to. Because Discord's voice platform is widely distributed, users should never cache or save the results of this call. To inform the gateway of our intent to establish voice connectivity, we first send an Opcode 4 Gateway Voice State Update:",
            "|Gateway Voice State Update Example"
          ],
          "Gateway Voice State Update Example": {
            "content": [
              {
                "language": "json",
                "code": "{\n  \"op\": 4,\n  \"d\": {\n    \"guild_id\": \"41771983423143937\",\n    \"channel_id\": \"127121515262115840\",\n    \"self_mute\": false,\n    \"self_deaf\": false\n  }\n}\n"
              },
              "If our request succeeded, the gateway will respond with two events\u2014a Voice State Update event and a Voice Server Update event\u2014meaning your library must properly wait for both events before continuing. The first will contain a new key, session_id, and the second will provide voice server information we can use to establish a new voice connection:",
              "|Example Voice Server Update Payload"
            ],
            "Example Voice Server Update Payload": {
              "content": [
                {
                  "language": "json",
                  "code": "{\n  \"t\": \"VOICE_SERVER_UPDATE\",\n  \"s\": 2,\n  \"op\": 0,\n  \"d\": {\n    \"token\": \"my_token\",\n    \"guild_id\": \"41771983423143937\",\n    \"endpoint\": \"smart.loyal.discord.gg\"\n  }\n}\n"
                },
                "With this information, we can move on to establishing a voice WebSocket connection.",
                "> info\n> Bot users respect the voice channel's user limit, if set. When the voice channel is full, you will not receive\n> the Voice State Update or Voice Server Update events in response to your own Voice State Update. Having MANAGE_CHANNELS\n> permission bypasses this limit and allows you to join regardless of the channel being full or not."
              ]
            }
          }
        }
      },
      "Establishing a Voice Websocket Connection": {
        "content": [
          "Once we retrieve a session_id, token, and endpoint information, we can connect and handshake with the voice server over another secure WebSocket. Unlike the gateway endpoint we receive in an HTTP Get Gateway request, the endpoint received from our Voice Server Update payload does not contain a URL protocol, so some libraries may require manually prepending it with \"wss://\" before connecting. Once connected to the voice WebSocket endpoint, we can send an Opcode 0 Identify payload with our server_id, user_id, session_id, and token:",
          "|Example Voice Identify Payload"
        ],
        "Example Voice Identify Payload": {
          "content": [
            {
              "language": "json",
              "code": "{\n  \"op\": 0,\n  \"d\": {\n    \"server_id\": \"41771983423143937\",\n    \"user_id\": \"104694319306248192\",\n    \"session_id\": \"my_session_id\",\n    \"token\": \"my_token\"\n  }\n}\n"
            },
            "The voice server should respond with an Opcode 2 Ready payload, which informs us of the SSRC, UDP IP/port, and supported encryption modes the voice server expects:",
            "|Example Voice Ready Payload"
          ],
          "Example Voice Ready Payload": {
            "content": [
              {
                "language": "json",
                "code": "{\n    \"op\": 2,\n    \"d\": {\n        \"ssrc\": 1,\n        \"ip\": \"127.0.0.1\",\n        \"port\": 1234,\n        \"modes\": [\"xsalsa20_poly1305\", \"xsalsa20_poly1305_suffix\", \"xsalsa20_poly1305_lite\"],\n        \"heartbeat_interval\": 1\n    }\n}\n"
              },
              "> danger\n> heartbeat_interval here is an erroneous field and should be ignored. The correct heartbeat_interval value comes from the Hello payload."
            ]
          }
        }
      },
      "Heartbeating": {
        "content": [
          "In order to maintain your WebSocket connection, you need to continuously send heartbeats at the interval determined in Opcode 8 Hello:",
          "|Example Hello Payload below V3"
        ],
        "Example Hello Payload below V3": {
          "content": [
            {
              "language": "json",
              "code": "{\n  \"heartbeat_interval\": 41250\n}\n"
            },
            "|Example Hello Payload since V3"
          ],
          "Example Hello Payload since V3": {
            "content": [
              {
                "language": "json",
                "code": "{\n  \"op\": 8,\n  \"d\": {\n    \"heartbeat_interval\": 41250\n  }\n}\n"
              },
              "This is sent at the start of the connection. Be warned that the Opcode 8 Hello structure differs by gateway version as shown in the above examples. Versions below v3 do not have an opcode or a data field denoted by d. V3 and above was updated to be structured like other payloads. Be sure to expect this different format based on your version.",
              "After receiving Opcode 8 Hello, you should send Opcode 3 Heartbeat\u2014which contains an integer nonce\u2014every elapsed interval:",
              "|Example Heartbeat Payload"
            ],
            "Example Heartbeat Payload": {
              "content": [
                {
                  "language": "json",
                  "code": "{\n  \"op\": 3,\n  \"d\": 1501184119561\n}\n"
                },
                "In return, you will be sent back an Opcode 6 Heartbeat ACK that contains the previously sent nonce:",
                "|Example Heartbeat ACK Payload"
              ],
              "Example Heartbeat ACK Payload": {
                "content": [
                  {
                    "language": "json",
                    "code": "{\n  \"op\": 6,\n  \"d\": 1501184119561\n}\n"
                  }
                ]
              }
            }
          }
        }
      },
      "Establishing a Voice UDP Connection": {
        "content": [
          "Once we receive the properties of a UDP voice server from our Opcode 2 Ready payload, we can proceed to the final step of voice connections, which entails establishing and handshaking a UDP connection for voice data. First, we open a UDP connection to the IP and port provided in the Ready payload. If required, we can now perform an IP Discovery using this connection. Once we've fully discovered our external IP and UDP port, we can then tell the voice WebSocket what it is, and start receiving/sending data. We do this using Opcode 1 Select Protocol:",
          "|Example Select Protocol Payload"
        ],
        "Example Select Protocol Payload": {
          "content": [
            {
              "language": "json",
              "code": "{\n    \"op\": 1,\n    \"d\": {\n        \"protocol\": \"udp\",\n        \"data\": {\n            \"address\": \"127.0.0.1\",\n            \"port\": 1337,\n            \"mode\": \"xsalsa20_poly1305_lite\"\n        }\n    }\n}\n"
            },
            "|Encryption Modes"
          ],
          "Encryption Modes": {
            "content": [
              [
                [
                  "Mode",
                  "Key",
                  "Nonce Bytes",
                  "Generating Nonce"
                ],
                [
                  "Normal",
                  "xsalsa20_poly1305",
                  "The nonce bytes are the RTP header",
                  "Copy the RTP header"
                ],
                [
                  "Suffix",
                  "xsalsa20_poly1305_suffix",
                  "The nonce bytes are 24 bytes appended to the payload of the RTP packet",
                  "Generate 24 random bytes"
                ],
                [
                  "Lite",
                  "xsalsa20_poly1305_lite",
                  "The nonce bytes are 4 bytes appended to the payload of the RTP packet",
                  "Incremental 4 bytes (32bit) int value"
                ]
              ],
              "> warn\n> The nonce has to be stripped from the payload before encrypting and before decrypting the audio data",
              "Finally, the voice server will respond with a Opcode 4 Session Description that includes the mode and secret_key, a 32 byte array used for encrypting and sending voice data:",
              "|Example Session Description Payload"
            ],
            "Example Session Description Payload": {
              "content": [
                {
                  "language": "json",
                  "code": "{\n    \"op\": 4,\n    \"d\": {\n        \"mode\": \"xsalsa20_poly1305_lite\",\n        \"secret_key\": [ ...251, 100, 11...]\n    }\n}\n"
                },
                "We can now start encrypting and sending voice data over the previously established UDP connection."
              ]
            }
          }
        }
      },
      "Encrypting and Sending Voice": {
        "content": [
          "Voice data sent to discord should be encoded with Opus, using two channels (stereo) and a sample rate of 48kHz. Voice Data is sent using a RTP Header, followed by encrypted Opus audio data. Voice encryption uses the key passed in Opcode 4 Session Description and the nonce formed with the 12 byte header appended with 12 null bytes to achieve the 24 required by xsalsa20_poly1305. Discord encrypts with the libsodium encryption library.",
          "|Voice Packet Structure"
        ],
        "Voice Packet Structure": {
          "content": [
            [
              [
                "Field",
                "Type",
                "Size"
              ],
              [
                "Version + Flags",
                "Single byte value of 0x80",
                "1 byte"
              ],
              [
                "Payload Type",
                "Single byte value of 0x78",
                "1 byte"
              ],
              [
                "Sequence",
                "Unsigned short (big endian)",
                "2 bytes"
              ],
              [
                "Timestamp",
                "Unsigned integer (big endian)",
                "4 bytes"
              ],
              [
                "SSRC",
                "Unsigned integer (big endian)",
                "4 bytes"
              ],
              [
                "Encrypted audio",
                "Binary data",
                "n bytes"
              ]
            ]
          ]
        }
      },
      "Speaking": {
        "content": [
          "To notify clients that you are speaking or have stopped speaking, send an Opcode 5 Speaking payload:",
          "The following flags can be used as a bitwise mask. For example 5 would be priority and voice.",
          [
            [
              "Flag",
              "Meaning",
              "Value"
            ],
            [
              "Microphone",
              "Normal transmission of voice audio",
              "1 << 0"
            ],
            [
              "Soundshare",
              "Transmission of context audio for video, no speaking indicator",
              "1 << 1"
            ],
            [
              "Priority",
              "Priority speaker, lowering audio of other speakers",
              "1 << 2"
            ]
          ],
          "|Example Speaking Payload",
          "|Voice Data Interpolation"
        ],
        "Example Speaking Payload": {
          "content": [
            {
              "language": "json",
              "code": "{\n    \"op\": 5,\n    \"d\": {\n        \"speaking\": 5,\n        \"delay\": 0,\n        \"ssrc\": 1\n    }\n}\n"
            },
            "> warn\n> You must send at least one Opcode 5 Speaking payload before sending voice data, or you will be disconnected with an invalid SSRC error."
          ]
        },
        "Voice Data Interpolation": {
          "content": [
            "When there's a break in the sent data, the packet transmission shouldn't simply stop. Instead, send five frames of silence (0xF8, 0xFF, 0xFE) before stopping to avoid unintended Opus interpolation with subsequent transmissions."
          ]
        }
      },
      "Resuming Voice Connection": {
        "content": [
          "When your client detects that its connection has been severed, it should open a new WebSocket connection. Once the new connection has been opened, your client should send an Opcode 7 Resume payload:",
          "|Example Resume Connection Payload"
        ],
        "Example Resume Connection Payload": {
          "content": [
            {
              "language": "json",
              "code": "{\n  \"op\": 7,\n  \"d\": {\n    \"server_id\": \"41771983423143937\",\n    \"session_id\": \"my_session_id\",\n    \"token\": \"my_token\"\n  }\n}\n"
            },
            "If successful, the Voice server will respond with an Opcode 9 Resumed to signal that your client is now resumed:",
            "|Example Resumed Payload",
            "|IP Discovery"
          ],
          "Example Resumed Payload": {
            "content": [
              {
                "language": "json",
                "code": "{\n  \"op\": 9,\n  \"d\": null\n}\n"
              },
              "If the resume is unsuccessful\u2014for example, due to an invalid session\u2014the WebSocket connection will close with the appropriate close event code. You should then follow the Connecting flow to reconnect."
            ]
          },
          "IP Discovery": {
            "content": [
              "Generally routers on the Internet mask or obfuscate UDP ports through a process called NAT. Most users who implement voice will want to utilize IP discovery to find their external IP and port which will then be used for receiving voice communications. To retrieve your external IP and port, send the following UDP packet to your voice port (all numeric are big endian):",
              [
                [
                  "Field",
                  "Description",
                  "Size"
                ],
                [
                  "Type",
                  "Values 0x1 and 0x2 indicate request and response, respectively",
                  "2 bytes"
                ],
                [
                  "Length",
                  "Message length excluding Type and Length fields (value 70)",
                  "2 bytes"
                ],
                [
                  "SSRC",
                  "Unsigned integer",
                  "4 bytes"
                ],
                [
                  "Address",
                  "Null-terminated string in response",
                  "64 bytes"
                ],
                [
                  "Port",
                  "Unsigned short",
                  "2 bytes"
                ]
              ]
            ]
          }
        }
      }
    }
  }
}